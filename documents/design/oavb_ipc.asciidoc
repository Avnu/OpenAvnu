= Interprocess Communication Recommendations for AVB/TSN
Andrew Elder and David Cemin
v0.2

// Use attribute to shorten urls
:repo: https://github.com/AVnu/Open-AVB
:img: {repo}/tree/gh-pages/images

== Introduction

The AVB/TSN software stack is comprised of a number of modules that implement protocol stacks specified by IEEE standards. Each of these protocols implement an  network facing interface and an application facing interface. The required application facing interface is described in some detail in http://avnu.org/wp-content/uploads/2014/05/AVnu_SWAPIs_v1.0.pdf[AVB Software Interfaces and Endpoint Architecture Guidelines]. Since a module running a particular protocol may be a standalone execution unit (for example a Linux daemon), an interprocess communication method is required to interface to the execution unit.

For portability reasons it is recommended to separate the implementation of the interprocess communication method as much as possible from the logic of the protocol implementation. This applies to both an application that is interfacing to an AVB/TSN module and the implementation of the AVB/TSN module itself.

Throughout this document the following terminology will be used.

Blocking call::
  Blocking means that the thread of execution is interrupted at some point to wait for an event of some type before completing.

Non-blocking call::
  Non-blocking means that the thread of execution completes the call without interruption.

Synchronous call::
  The call completes and return status information is available immediately because it was returned when the call returned. Also the calling application knows that all requested operations have been completed when the call returns.

Asynchronous call::
  The call completes but return status information is returned on by way of a different mechanism. The calling application does not know that requested operations have been completed and must rely on an alternative notification communication mechanism to confirm successful completion of requested operations.


== Synchronous Communication Interfaces

For the purposes of this document the following straw-man application interfaces are described:

.Straw-man Interfaces
[source,c/c++]
----


/**
 * \brief  An example showing setting of parameter XYZ.
 * \param  setting  The new value of XYZ.
 * \param  out Pointer to detailed status code.
 * \return 0 on success, -1 on failure.
 */
int AVBTSN_SetXYZ(uint32_t setting, void *out);


/**
 * \brief  An example showing a command that requires multiple parameters.
 * \param  stream_id The stream_id used by commanXYZ.
 * \param  vlan The vlan used by commanXYZ.
 * \param  out Pointer to detailed status code
 * \return 0 on success, -1 on failure.
 */
int AVBTSN_CommandXYZ(uint64_t stream_id, uint32_t vlan, void *out);


----

where the AVBTSN portion of the function name would be replaced by the name of the IEEE AVB/TSN protocol module that is being targeted.

The synchronous communication interface is exposed by the module itself. If a single monolithic application is being produced, it is possible that the synchronous communication interface could be used to call module functionality directly. In this situation the module functions being called will execute within the context of the parent monolithic application.
The synchonous communication interface is exposed by the module itself.

The examples show two types of IPC commands, one with a single parameter and another one with multiple parameters. These functions return a code to indicate success / failure and have an out pointer, which should provide more detailed information about the reason of failure.

.... Another option for multiple paramters would be creating a structure type with all the parameters. TODO: Discuss it with Andrew.

=== Defining Error Codes

The IPC calls can and will fail eventually and it is necessary to let the caller know what was the error cause. Each IPC command should have an 'out' pointer that would provide more details about the error. The example below shows one way of creating these codes:

[source c/c++]
----
typedef enum {
	AVBTSN_IPC_SUCCESS = 0,
	AVBTSN_IPC_GENERIC_ERROR1,
	AVBTSN_IPC_GENERIC_ERROR2,
} AVBTSN_ipc_t;

struct {
	AVBTSN_ipc_t error_code;
	char *error_str;
} AVBTSN_IpcErrorCode[] = {
	{AVBTSN_IPC_SUCCESS, "IPC Success."},
	{AVBTSN_IPC_GENERIC_ERROR1, "IPC Generic Error 1."},
	{AVBTSN_IPC_GENERIC_ERROR2, "IPC Generic Error 2."},
};
----

where the AVBTSN portion of the function name would be replaced by the name of the IEEE AVB/TSN protocol module that is being targeted. The generic error codes shall be replaced by the actual failure information to be implemented.

.... The Module could also provide functions to transform the error codes (the enumeration type) in strings. 

Any errors returned should be #defined in a public interface module (typically a .h header file in C) so that the calling application can correctly interpret the returned errors and make decisions on actions to undertake depending on the error returned.
.... more text about this being usable for single .exe implementation

The synchronous communication interface turns out to be the same interface that is used in the module interface layer in the asynchronous communication case. The module interface layer can potentially have many different calling interfaces layered on top of it.
.... text about this being the public interface to the module and that async communication is implemented as a layer on top of this interface.


== Asynchronous Communication Interfaces

The asynchronous communication interface sits on top of the synchronous communication interface. It includes features to support error reporting, even though the errors may be handled by a different execution thread, or at a later time.

If application blocking to wait for a command to complete is desired, this can also be supported.  

.Block image
image::{img}/ipc1.png[]

=== Communication Stack Abstraction

This section outlines abstraction requirements for multiple layers. The layers that will be described here are represented in the following table.

[width="85%",options="header"]
|=======
|Layer |Description
|Application |Call APIs for AVB/TSN module
|Packing |Takes parameters from API calls and packs them for "transport"
|Communication |Send packed parameters
|Channel |Transfer information from source to destination
|Communication |Receive packed parameters
|Unpacking |Unpacks information from channel
|Module |This is the layer with equivalent calls to the top Application layer
|=======

==== Application Layer

The application layer is the layer that an external client application uses to call an underlying module that implements a particular AVB/TSN protocol. The application layer requires a simple interface that has parameters that closely match those supported by the underlying module implementation. However, since the context for an underlying communication layer is required, an additional IPC context parameter must be added to the application's calling interface. The example straw-man interface now becomes:

.Straw-man Interfaces for External Application
[source,c/c++]
----
/*
 * An example showing setting of parameter XYZ.
 * /param ipc_context The interprocess communication context that was returned from an create_call. This contains information for the communication channel that is in use.
 * /param this_call_context This variable is used by the application to track the call status return. Upon completion of the call it is returned to the application. A recommended use for the this_call_conext would be for the calling application to allocate a structure that contains details of the command being called. A non-blocking implementation will return this pointer when the call status is returned and the application can decide on the appropriate action to take at that time.
 * /param setting The new value of XYZ.
 * /return 0 on success, otherwise a defined error code.
 */
void AVBTSN_SetParam(void *ipc_context, void *this_call_context, uint32_t param);

----

==== Packing Layer

The marshalling layer is responsible for encoding parameters into a defined structure for passing through the communication layer. The structure will include a field that defines what the structure contains and how large it is. This is so as to support routing the information to the correct synchronous call once the structure has passed over the communication channel. The packed layout should be in a standalone header file so that both the packing/send module and the unpacking/receiver module can reference that same layout specification.


.Straw-man packed structure layout example
[source,c/c++]
----

#define AVBTSN_COMMAND_SET_XYZ 1
#define AVBTSN_COMMAND_START 2

struct avbtsn_packing_header {
	uint32_t size;
	uint32_t command; /* #def'd above */
	void *this_call_context;
};

struct avbtsn_packing_command_set_xyz {
	struct avbtsn_packing_header header;
	int param;
};

struct avbtsn_packing_command_start {
	struct avbtsn_packing_header header;
	uint64_t streamID;
	uint32_t vlan;
};

----

Upon calling from the application, the packing layer performs the following operations
 1. allocates the correctly sized packing structure
 1. fills in the header size, command and this_call_context fields
 1. fills in call specific parameters and submits the data to the communication layer

After the application has sent a command it should call the communication layer again to recieve a response. This call could be via a explicit call, or in the case of single threaded application design a poll/WaitForMultipleObjects loop would handle an event for the receive socket/handle that indicates a packet of information containing the call response is ready to be processed.


==== Abstract Communication Layer

The communication layer has interfaces to open, close, send and receive data. The exact mechanisms for any of these functions depends on the concrete implementation which could cover Linux domain sockets, UDP, shared memory pipe, shared memory structures or any other implementation.

[source,c/c++]
----
struct oavb_ipc {
	void *private;
	int (*close)(struct oavb_ipc *ipc, void *flags);
	int (*open) (struct oavb_ipc *ipc, void *flags);
	int (*bind) (struct oavb_ipc *ipc, void *flags);
	int (*recv) (struct oavb_ipc *ipc, void *buf, int buflen);
	int (*send) (struct oavb_ipc *ipc, void *buf, int buflen);
	void (*free) (struct oavb_ipc *ipc);
#if defined __linux__
	int (*get_fd) (struct oavb_ipc *ipc);
#endif
};
----

==== Unpacking Layer

The unpacking layer performs the inverse of the packing layer. Parameters are extracted from whatever structure or buffer they were stored in by the external application and the parameters are then used to called the specified interface within the module.

==== Module Interface Layer

This layer consists of a public interface used to make calls to functions within the module. Parameters required by each call are explicitly defined.



